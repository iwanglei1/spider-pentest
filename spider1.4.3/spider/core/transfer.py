# date: 2020/1/14 10:10
# author: liyong
import os
import re
import setting
import csv
from datetime import datetime
from docx import Document
from docx.shared import Cm
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from . import const
from .utils import print_progress


class Transfer(object):
    """将csv数据转换为漏洞日报word版"""
    _max_cols = const.affected_products + 1

    def __init__(self, path):
        self.flag = ''
        self.__get_file_name(path)
        self.docx = ''
        self.csv_rows = []
        if not self.flag:
            self.csv_rows = self.__load_csv_data()
            if self.csv_rows:
                self.docx = Document(setting.file_vul_daily_template)

    def __get_file_name(self, path):
        self.csv_path = path
        (filepath, tempfilename) = os.path.split(path)
        (filename, extension) = os.path.splitext(tempfilename)
        (tempfilepath, filedate) = os.path.split(filepath)
        self.file_path = filepath
        self.file_date = filedate
        print(f'要转换csv文件：{path}')
        if extension != '.csv':
            print('当前文件不是有效的csv文件.')
            self.flag = const.flag_invalid_csv

    def __load_csv_data(self):
        rows = []
        try:
            with open(self.csv_path, 'r') as csvfile:
                reader = csv.reader(csvfile)
                for row in reader:
                    if row[const.cnnvd_id] == 'CNNVD编号':
                        continue
                    new = self.__pack_csv_data(row)
                    if not new:
                        continue
                    rows.append(new)
            if not rows:
                print(f'当前csv文件数据不完整，请检查！')
                self.flag = const.flag_incomplete_csv
        except FileNotFoundError:
            print('要转换的文件路径不存在，请检查是否正确.')
            self.flag = const.flag_none_csv
        return rows

    def __pack_csv_data(self, row):
        """将采集的csv文件打包格式"""
        new = []
        if not row[const.cnnvd_title]:
            return new
        if len(row) < self._max_cols:
            for i in range(0, self._max_cols - len(row)):   # 缺少的列补充空白字符
                row.append('')
        title = f'{row[const.cnnvd_title]}({row[const.cve_id]})'    # 取漏洞全称
        date = row[const.release_date]
        if re.match(r"[0-9][0-9][0-9][0-9]+\/\d+\/\d+", date):
            datetimeobject = datetime.strptime(date, '%Y/%m/%d')
            new_string = datetimeobject.strftime('%Y-%m-%d')        # 将日期转换为%Y-%m-%d
            date = new_string
        cve_level = row[const.cve_level]
        cnnvd_level = row[const.cnnvd_level]
        if cve_level == 'N/A' or cve_level == 'NULL':
            level = cnnvd_level
        else:
            level = cve_level
        if '危' in level:
            level = level.rstrip('危')
        else:
            level = '暂无'
        cvss = '暂无'
        if row[const.cve_score] != 'N/A' and row[const.cve_score] != 'NULL':
            cvss = row[const.cve_score] + row[const.cve_cvss]
        version = '无'
        affected_version = row[const.affected_version]
        if affected_version != 'N/A' and affected_version != 'NULL':
            version = affected_version
        products = ''
        if row[const.affected_products]:
            products = row[const.affected_products]
        cveid = ''
        if row[const.cve_id]:
            cveid = row[const.cve_id]
        des = ''
        if row[const.vul_des]:
            des = row[const.vul_des]
        if row[const.cve_level] != 'NULL':
            link = row[const.cve_href]
        else:
            link = row[const.cnnvd_href]
        solution = ''
        if row[const.vul_notice]:
            solution = row[const.vul_notice]
        new = [date, level, cvss, version, '否', products, cveid, des, link, solution, title]
        return new

    @staticmethod
    def __make_one_table(document, row):
        left_title = ['发布时间', '危害级别', 'CVSS3.0', '存在漏洞的\n组件版本', '是否有POC（POC链接）', '受影响产品线（初步评估）',
                      'CVE ID', '漏洞描述', '参考链接', '漏洞解决方案']
        table_rows = len(left_title)
        table = document.add_table(rows=table_rows, cols=2)
        table.style = 'Table_template'
        table.autofit = False

        column_left = table.columns[0]
        column_right = table.columns[1]
        for i in range(table_rows):
            column_left.cells[i].text = left_title[i]
            column_left.cells[i].width = Cm(3.0)
            column_left.cells[i].paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT
            column_right.cells[i].text = row[i]
            column_right.cells[i].width = Cm(11.75)

    def make_daily_docx(self):
        """生成日报word"""
        if self.flag:
            return
        document = self.docx
        cur_time = datetime.now().strftime('%H%M%S')
        for index, row in enumerate(self.csv_rows):
            print_progress('正在生成word文档', index + 1, len(self.csv_rows))
            title = row[const.docx_title]
            if not title:
                continue
            document.add_heading(title, level=1)
            self.__make_one_table(document, row)
        file_path = os.path.join(self.file_path, f'安全漏洞日报{self.file_date}_{cur_time}.docx')
        try:
            document.save(file_path)
            print(f'\r{file_path}保存成功.')
            print('')
        except PermissionError:
            print(f'保存失败，同名文件已打开，没有权限保存.')
        except Exception as er:
            print(f'保存失败，异常原因：{er}')
